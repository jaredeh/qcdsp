diff --git a/demo/calculator.idl b/demo/calculator.idl
index 5ec9ca0..ee25cb3 100644
--- a/demo/calculator.idl
+++ b/demo/calculator.idl
@@ -1,4 +1,5 @@
 interface calculator {
   long sum(in sequence<long> vec, rout long long res);
+  long sum2();
 };
 
diff --git a/demo/calculator_imp.c b/demo/calculator_imp.c
index e0ae70c..b0f8d10 100644
--- a/demo/calculator_imp.c
+++ b/demo/calculator_imp.c
@@ -8,3 +8,7 @@ int calculator_sum(const int* vec, int vecLen, int64* res) {
   }
   return 0;
 }
+
+int calculator_sum2() {
+  return 0;
+}
diff --git a/demo/out/calculator.h b/demo/out/calculator.h
index 3cdc2ab..c6fd6fd 100644
--- a/demo/out/calculator.h
+++ b/demo/out/calculator.h
@@ -28,6 +28,7 @@
 extern "C" {
 #endif
 __QAIC_HEADER_EXPORT int __QAIC_HEADER(calculator_sum)(const int* vec, int vecLen, int64* res) __QAIC_HEADER_ATTRIBUTE;
+__QAIC_HEADER_EXPORT int __QAIC_HEADER(calculator_sum2)(void) __QAIC_HEADER_ATTRIBUTE;
 #ifdef __cplusplus
 }
 #endif
diff --git a/demo/out/calculator_skel.c b/demo/out/calculator_skel.c
index 88ee48b..a7a98d2 100644
--- a/demo/out/calculator_skel.c
+++ b/demo/out/calculator_skel.c
@@ -1,412 +1,412 @@
 #ifndef _CALCULATOR_SKEL_H
 #define _CALCULATOR_SKEL_H
 #include "calculator.h"
-#ifndef _QAIC_ENV_H
-#define _QAIC_ENV_H
-
-#ifdef __GNUC__
-#ifdef __clang__
-#pragma GCC diagnostic ignored "-Wunknown-pragmas"
-#else
-#pragma GCC diagnostic ignored "-Wpragmas"
-#endif
-#pragma GCC diagnostic ignored "-Wuninitialized"
-#pragma GCC diagnostic ignored "-Wunused-parameter"
-#pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-#ifndef _ATTRIBUTE_UNUSED
-
-#ifdef _WIN32
-#define _ATTRIBUTE_UNUSED
-#else
-#define _ATTRIBUTE_UNUSED __attribute__ ((unused))
-#endif
-
-#endif // _ATTRIBUTE_UNUSED
-
-#ifndef __QAIC_REMOTE
-#define __QAIC_REMOTE(ff) ff
-#endif //__QAIC_REMOTE
-
-#ifndef __QAIC_HEADER
-#define __QAIC_HEADER(ff) ff
-#endif //__QAIC_HEADER
-
-#ifndef __QAIC_HEADER_EXPORT
-#define __QAIC_HEADER_EXPORT
-#endif // __QAIC_HEADER_EXPORT
-
-#ifndef __QAIC_HEADER_ATTRIBUTE
-#define __QAIC_HEADER_ATTRIBUTE
-#endif // __QAIC_HEADER_ATTRIBUTE
-
-#ifndef __QAIC_IMPL
-#define __QAIC_IMPL(ff) ff
-#endif //__QAIC_IMPL
-
-#ifndef __QAIC_IMPL_EXPORT
-#define __QAIC_IMPL_EXPORT
-#endif // __QAIC_IMPL_EXPORT
-
-#ifndef __QAIC_IMPL_ATTRIBUTE
-#define __QAIC_IMPL_ATTRIBUTE
-#endif // __QAIC_IMPL_ATTRIBUTE
-
-#ifndef __QAIC_STUB
-#define __QAIC_STUB(ff) ff
-#endif //__QAIC_STUB
-
-#ifndef __QAIC_STUB_EXPORT
-#define __QAIC_STUB_EXPORT
-#endif // __QAIC_STUB_EXPORT
-
-#ifndef __QAIC_STUB_ATTRIBUTE
-#define __QAIC_STUB_ATTRIBUTE
-#endif // __QAIC_STUB_ATTRIBUTE
-
-#ifndef __QAIC_SKEL
-#define __QAIC_SKEL(ff) ff
-#endif //__QAIC_SKEL__
-
-#ifndef __QAIC_SKEL_EXPORT
-#define __QAIC_SKEL_EXPORT
-#endif // __QAIC_SKEL_EXPORT
-
-#ifndef __QAIC_SKEL_ATTRIBUTE
-#define __QAIC_SKEL_ATTRIBUTE
-#endif // __QAIC_SKEL_ATTRIBUTE
-
-#ifdef __QAIC_DEBUG__
-   #ifndef __QAIC_DBG_PRINTF__
-   #include <stdio.h>
-   #define __QAIC_DBG_PRINTF__( ee ) do { printf ee ; } while(0)
-   #endif
-#else
-   #define __QAIC_DBG_PRINTF__( ee ) (void)0
-#endif
-
-
-#define _OFFSET(src, sof)  ((void*)(((char*)(src)) + (sof)))
-
-#define _COPY(dst, dof, src, sof, sz)  \
-   do {\
-         struct __copy { \
-            char ar[sz]; \
-         };\
-         *(struct __copy*)_OFFSET(dst, dof) = *(struct __copy*)_OFFSET(src, sof);\
-   } while (0)
-
-#define _COPYIF(dst, dof, src, sof, sz)  \
-   do {\
-      if(_OFFSET(dst, dof) != _OFFSET(src, sof)) {\
-         _COPY(dst, dof, src, sof, sz); \
-      } \
-   } while (0)
-
-_ATTRIBUTE_UNUSED
-static __inline void _qaic_memmove(void* dst, void* src, int size) {
-   int i;
-   for(i = 0; i < size; ++i) {
-      ((char*)dst)[i] = ((char*)src)[i];
-   }
-}
-
-#define _MEMMOVEIF(dst, src, sz)  \
-   do {\
-      if(dst != src) {\
-         _qaic_memmove(dst, src, sz);\
-      } \
-   } while (0)
-
-
-#define _ASSIGN(dst, src, sof)  \
-   do {\
-      dst = OFFSET(src, sof); \
-   } while (0)
-
-#define _STD_STRLEN_IF(str) (str == 0 ? 0 : strlen(str))
-
-#include "AEEStdErr.h"
-
-#define _TRY(ee, func) \
-   do { \
-      if (AEE_SUCCESS != ((ee) = func)) {\
-         __QAIC_DBG_PRINTF__((__FILE__ ":%d:error:%d:%s\n", __LINE__, (int)(ee),#func));\
-         goto ee##bail;\
-      } \
-   } while (0)
-
-#define _CATCH(exception) exception##bail: if (exception != AEE_SUCCESS)
-
-#define _ASSERT(nErr, ff) _TRY(nErr, 0 == (ff) ? AEE_EBADPARM : AEE_SUCCESS)
-
-#ifdef __QAIC_DEBUG__
-#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, __FILE_LINE__, size, alignment, (void**)&pv));\
-                                                  _ASSERT(nErr,pv || !(size))   
-#else
-#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, 0, size, alignment, (void**)&pv));\
-                                                  _ASSERT(nErr,pv || !(size))
-#endif
-
-
-#endif // _QAIC_ENV_H
+#ifndef _QAIC_ENV_H
+#define _QAIC_ENV_H
+
+#ifdef __GNUC__
+#ifdef __clang__
+#pragma GCC diagnostic ignored "-Wunknown-pragmas"
+#else
+#pragma GCC diagnostic ignored "-Wpragmas"
+#endif
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#pragma GCC diagnostic ignored "-Wunused-parameter"
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
+#ifndef _ATTRIBUTE_UNUSED
+
+#ifdef _WIN32
+#define _ATTRIBUTE_UNUSED
+#else
+#define _ATTRIBUTE_UNUSED __attribute__ ((unused))
+#endif
+
+#endif // _ATTRIBUTE_UNUSED
+
+#ifndef __QAIC_REMOTE
+#define __QAIC_REMOTE(ff) ff
+#endif //__QAIC_REMOTE
+
+#ifndef __QAIC_HEADER
+#define __QAIC_HEADER(ff) ff
+#endif //__QAIC_HEADER
+
+#ifndef __QAIC_HEADER_EXPORT
+#define __QAIC_HEADER_EXPORT
+#endif // __QAIC_HEADER_EXPORT
+
+#ifndef __QAIC_HEADER_ATTRIBUTE
+#define __QAIC_HEADER_ATTRIBUTE
+#endif // __QAIC_HEADER_ATTRIBUTE
+
+#ifndef __QAIC_IMPL
+#define __QAIC_IMPL(ff) ff
+#endif //__QAIC_IMPL
+
+#ifndef __QAIC_IMPL_EXPORT
+#define __QAIC_IMPL_EXPORT
+#endif // __QAIC_IMPL_EXPORT
+
+#ifndef __QAIC_IMPL_ATTRIBUTE
+#define __QAIC_IMPL_ATTRIBUTE
+#endif // __QAIC_IMPL_ATTRIBUTE
+
+#ifndef __QAIC_STUB
+#define __QAIC_STUB(ff) ff
+#endif //__QAIC_STUB
+
+#ifndef __QAIC_STUB_EXPORT
+#define __QAIC_STUB_EXPORT
+#endif // __QAIC_STUB_EXPORT
+
+#ifndef __QAIC_STUB_ATTRIBUTE
+#define __QAIC_STUB_ATTRIBUTE
+#endif // __QAIC_STUB_ATTRIBUTE
+
+#ifndef __QAIC_SKEL
+#define __QAIC_SKEL(ff) ff
+#endif //__QAIC_SKEL__
+
+#ifndef __QAIC_SKEL_EXPORT
+#define __QAIC_SKEL_EXPORT
+#endif // __QAIC_SKEL_EXPORT
+
+#ifndef __QAIC_SKEL_ATTRIBUTE
+#define __QAIC_SKEL_ATTRIBUTE
+#endif // __QAIC_SKEL_ATTRIBUTE
+
+#ifdef __QAIC_DEBUG__
+   #ifndef __QAIC_DBG_PRINTF__
+   #include <stdio.h>
+   #define __QAIC_DBG_PRINTF__( ee ) do { printf ee ; } while(0)
+   #endif
+#else
+   #define __QAIC_DBG_PRINTF__( ee ) (void)0
+#endif
+
+
+#define _OFFSET(src, sof)  ((void*)(((char*)(src)) + (sof)))
+
+#define _COPY(dst, dof, src, sof, sz)  \
+   do {\
+         struct __copy { \
+            char ar[sz]; \
+         };\
+         *(struct __copy*)_OFFSET(dst, dof) = *(struct __copy*)_OFFSET(src, sof);\
+   } while (0)
+
+#define _COPYIF(dst, dof, src, sof, sz)  \
+   do {\
+      if(_OFFSET(dst, dof) != _OFFSET(src, sof)) {\
+         _COPY(dst, dof, src, sof, sz); \
+      } \
+   } while (0)
+
+_ATTRIBUTE_UNUSED
+static __inline void _qaic_memmove(void* dst, void* src, int size) {
+   int i;
+   for(i = 0; i < size; ++i) {
+      ((char*)dst)[i] = ((char*)src)[i];
+   }
+}
+
+#define _MEMMOVEIF(dst, src, sz)  \
+   do {\
+      if(dst != src) {\
+         _qaic_memmove(dst, src, sz);\
+      } \
+   } while (0)
+
+
+#define _ASSIGN(dst, src, sof)  \
+   do {\
+      dst = OFFSET(src, sof); \
+   } while (0)
+
+#define _STD_STRLEN_IF(str) (str == 0 ? 0 : strlen(str))
+
+#include "AEEStdErr.h"
+
+#define _TRY(ee, func) \
+   do { \
+      if (AEE_SUCCESS != ((ee) = func)) {\
+         __QAIC_DBG_PRINTF__((__FILE__ ":%d:error:%d:%s\n", __LINE__, (int)(ee),#func));\
+         goto ee##bail;\
+      } \
+   } while (0)
+
+#define _CATCH(exception) exception##bail: if (exception != AEE_SUCCESS)
+
+#define _ASSERT(nErr, ff) _TRY(nErr, 0 == (ff) ? AEE_EBADPARM : AEE_SUCCESS)
+
+#ifdef __QAIC_DEBUG__
+#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, __FILE_LINE__, size, alignment, (void**)&pv));\
+                                                  _ASSERT(nErr,pv || !(size))
+#else
+#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, 0, size, alignment, (void**)&pv));\
+                                                  _ASSERT(nErr,pv || !(size))
+#endif
+
+
+#endif // _QAIC_ENV_H
 
 #include "remote.h"
-#ifndef _ALLOCATOR_H
-#define _ALLOCATOR_H
-
-#include <stdlib.h>
-#include <stdint.h>
-
-typedef struct _heap _heap;
-struct _heap {
-   _heap* pPrev;
-   const char* loc;
-   uint64_t buf;
-};
-
-typedef struct _allocator {
-   _heap* pheap;
-   uint8_t* stack;
-   uint8_t* stackEnd;
-   int nSize;
-} _allocator;
-
-_ATTRIBUTE_UNUSED
-static __inline int _heap_alloc(_heap** ppa, const char* loc, int size, void** ppbuf) {
-   _heap* pn = 0;
-   pn = malloc(size + sizeof(_heap) - sizeof(uint64_t));
-   if(pn != 0) {
-      pn->pPrev = *ppa;
-      pn->loc = loc;
-      *ppa = pn;
-      *ppbuf = (void*)&(pn->buf);
-      return 0;
-   } else {
-      return -1;
-   }
-}
-#define _ALIGN_SIZE(x, y) (((x) + (y-1)) & ~(y-1))
-
-_ATTRIBUTE_UNUSED
-static __inline int _allocator_alloc(_allocator* me,
-                                    const char* loc,
-                                    int size,
-                                    unsigned int al,
-                                    void** ppbuf) {
-   if(size < 0) {
-      return -1;
-   } else if (size == 0) {
-      *ppbuf = 0;
-      return 0;
-   }
-   if((_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size) < (uintptr_t)me->stack + me->nSize) {
-      *ppbuf = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al);
-      me->stackEnd = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size;
-      return 0;
-   } else {
-      return _heap_alloc(&me->pheap, loc, size, ppbuf);
-   }
-}
-
-_ATTRIBUTE_UNUSED
-static __inline void _allocator_deinit(_allocator* me) {
-   _heap* pa = me->pheap;
-   while(pa != 0) {
-      _heap* pn = pa;
-      const char* loc = pn->loc;
-      (void)loc;
-      pa = pn->pPrev;
-      free(pn);
-   }
-}
-
-_ATTRIBUTE_UNUSED
-static __inline void _allocator_init(_allocator* me, uint8_t* stack, int stackSize) {
-   me->stack =  stack;
-   me->stackEnd =  stack + stackSize;
-   me->nSize = stackSize;
-   me->pheap = 0;
-}
-
-
-#endif // _ALLOCATOR_H
-
-#ifndef SLIM_H
-#define SLIM_H
-
-#include <stdint.h>
-
-//a C data structure for the idl types that can be used to implement
-//static and dynamic language bindings fairly efficiently.
-//
-//the goal is to have a minimal ROM and RAM footprint and without
-//doing too many allocations.  A good way to package these things seemed
-//like the module boundary, so all the idls within  one module can share
-//all the type references.
-
-
-#define PARAMETER_IN       0x0
-#define PARAMETER_OUT      0x1
-#define PARAMETER_INOUT    0x2
-#define PARAMETER_ROUT     0x3
-#define PARAMETER_INROUT   0x4
-
-//the types that we get from idl
-#define TYPE_OBJECT             0x0
-#define TYPE_INTERFACE          0x1
-#define TYPE_PRIMITIVE          0x2
-#define TYPE_ENUM               0x3
-#define TYPE_STRING             0x4
-#define TYPE_WSTRING            0x5
-#define TYPE_STRUCTURE          0x6
-#define TYPE_UNION              0x7
-#define TYPE_ARRAY              0x8
-#define TYPE_SEQUENCE           0x9
-
-//these require the pack/unpack to recurse
-//so it's a hint to those languages that can optimize in cases where
-//recursion isn't necessary.
-#define TYPE_COMPLEX_STRUCTURE  (0x10 | TYPE_STRUCTURE)
-#define TYPE_COMPLEX_UNION      (0x10 | TYPE_UNION)
-#define TYPE_COMPLEX_ARRAY      (0x10 | TYPE_ARRAY)
-#define TYPE_COMPLEX_SEQUENCE   (0x10 | TYPE_SEQUENCE)
-
-
-typedef struct Type Type;
-
-#define INHERIT_TYPE\
-   int32_t nativeSize;                /*in the simple case its the same as wire size and alignment*/\
-   union {\
-      struct {\
-         const uintptr_t         p1;\
-         const uintptr_t         p2;\
-      } _cast;\
-      struct {\
-         uint32_t  iid;\
-         uint32_t  bNotNil;\
-      } object;\
-      struct {\
-         const Type  *arrayType;\
-         int32_t      nItems;\
-      } array;\
-      struct {\
-         const Type *seqType;\
-         int32_t      nMaxLen;\
-      } seqSimple; \
-      struct {\
-         uint32_t bFloating;\
-         uint32_t bSigned;\
-      } prim; \
-      const SequenceType* seqComplex;\
-      const UnionType  *unionType;\
-      const StructType *structType;\
-      int32_t         stringMaxLen;\
-      uint8_t        bInterfaceNotNil;\
-   } param;\
-   uint8_t    type;\
-   uint8_t    nativeAlignment\
-
-typedef struct UnionType UnionType;
-typedef struct StructType StructType;
-typedef struct SequenceType SequenceType;
-struct Type {
-   INHERIT_TYPE;
-};
-
-struct SequenceType {
-   const Type *         seqType;
-   uint32_t               nMaxLen;
-   uint32_t               inSize;
-   uint32_t               routSizePrimIn;
-   uint32_t               routSizePrimROut;
-};
-
-//byte offset from the start of the case values for
-//this unions case value array.  it MUST be aligned
-//at the alignment requrements for the descriptor
-//
-//if negative it means that the unions cases are
-//simple enumerators, so the value read from the descriptor
-//can be used directly to find the correct case
-typedef union CaseValuePtr CaseValuePtr;
-union CaseValuePtr {
-   const uint8_t*   value8s;
-   const uint16_t*  value16s;
-   const uint32_t*  value32s;
-   const uint64_t*  value64s;
-};
-
-//these are only used in complex cases
-//so I pulled them out of the type definition as references to make
-//the type smaller
-struct UnionType {
-   const Type           *descriptor;
-   uint32_t               nCases;
-   const CaseValuePtr   caseValues;
-   const Type * const   *cases;
-   int32_t               inSize;
-   int32_t               routSizePrimIn;
-   int32_t               routSizePrimROut;
-   uint8_t                inAlignment;
-   uint8_t                routAlignmentPrimIn;
-   uint8_t                routAlignmentPrimROut;
-   uint8_t                inCaseAlignment;
-   uint8_t                routCaseAlignmentPrimIn;
-   uint8_t                routCaseAlignmentPrimROut;
-   uint8_t                nativeCaseAlignment;
-   uint8_t              bDefaultCase;
-};
-
-struct StructType {
-   uint32_t               nMembers;
-   const Type * const   *members;
-   int32_t               inSize;
-   int32_t               routSizePrimIn;
-   int32_t               routSizePrimROut;
-   uint8_t                inAlignment;
-   uint8_t                routAlignmentPrimIn;
-   uint8_t                routAlignmentPrimROut;
-};
-
-typedef struct Parameter Parameter;
-struct Parameter {
-   INHERIT_TYPE;
-   uint8_t    mode;
-   uint8_t  bNotNil;
-};
-
-#define SLIM_IFPTR32(is32,is64) (sizeof(uintptr_t) == 4 ? (is32) : (is64))
-#define SLIM_SCALARS_IS_DYNAMIC(u) (((u) & 0x00ffffff) == 0x00ffffff)
-
-typedef struct Method Method;
-struct Method {
-   uint32_t                    uScalars;            //no method index
-   int32_t                     primInSize;
-   int32_t                     primROutSize;
-   int                         maxArgs;
-   int                         numParams;
-   const Parameter * const     *params;
-   uint8_t                       primInAlignment;
-   uint8_t                       primROutAlignment;
-};
-
-typedef struct Interface Interface;
-
-struct Interface {
-   int                            nMethods;
-   const Method  * const          *methodArray;
-   int                            nIIds;
-   const uint32_t                   *iids;
-   const uint16_t*                  methodStringArray;
-   const uint16_t*                  methodStrings;
-   const char*                    strings;
-};
-
-
-#endif //SLIM_H
-
+#ifndef _ALLOCATOR_H
+#define _ALLOCATOR_H
+
+#include <stdlib.h>
+#include <stdint.h>
+
+typedef struct _heap _heap;
+struct _heap {
+   _heap* pPrev;
+   const char* loc;
+   uint64_t buf;
+};
+
+typedef struct _allocator {
+   _heap* pheap;
+   uint8_t* stack;
+   uint8_t* stackEnd;
+   int nSize;
+} _allocator;
+
+_ATTRIBUTE_UNUSED
+static __inline int _heap_alloc(_heap** ppa, const char* loc, int size, void** ppbuf) {
+   _heap* pn = 0;
+   pn = malloc(size + sizeof(_heap) - sizeof(uint64_t));
+   if(pn != 0) {
+      pn->pPrev = *ppa;
+      pn->loc = loc;
+      *ppa = pn;
+      *ppbuf = (void*)&(pn->buf);
+      return 0;
+   } else {
+      return -1;
+   }
+}
+#define _ALIGN_SIZE(x, y) (((x) + (y-1)) & ~(y-1))
+
+_ATTRIBUTE_UNUSED
+static __inline int _allocator_alloc(_allocator* me,
+                                    const char* loc,
+                                    int size,
+                                    unsigned int al,
+                                    void** ppbuf) {
+   if(size < 0) {
+      return -1;
+   } else if (size == 0) {
+      *ppbuf = 0;
+      return 0;
+   }
+   if((_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size) < (uintptr_t)me->stack + me->nSize) {
+      *ppbuf = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al);
+      me->stackEnd = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size;
+      return 0;
+   } else {
+      return _heap_alloc(&me->pheap, loc, size, ppbuf);
+   }
+}
+
+_ATTRIBUTE_UNUSED
+static __inline void _allocator_deinit(_allocator* me) {
+   _heap* pa = me->pheap;
+   while(pa != 0) {
+      _heap* pn = pa;
+      const char* loc = pn->loc;
+      (void)loc;
+      pa = pn->pPrev;
+      free(pn);
+   }
+}
+
+_ATTRIBUTE_UNUSED
+static __inline void _allocator_init(_allocator* me, uint8_t* stack, int stackSize) {
+   me->stack =  stack;
+   me->stackEnd =  stack + stackSize;
+   me->nSize = stackSize;
+   me->pheap = 0;
+}
+
+
+#endif // _ALLOCATOR_H
+
+#ifndef SLIM_H
+#define SLIM_H
+
+#include <stdint.h>
+
+//a C data structure for the idl types that can be used to implement
+//static and dynamic language bindings fairly efficiently.
+//
+//the goal is to have a minimal ROM and RAM footprint and without
+//doing too many allocations.  A good way to package these things seemed
+//like the module boundary, so all the idls within  one module can share
+//all the type references.
+
+
+#define PARAMETER_IN       0x0
+#define PARAMETER_OUT      0x1
+#define PARAMETER_INOUT    0x2
+#define PARAMETER_ROUT     0x3
+#define PARAMETER_INROUT   0x4
+
+//the types that we get from idl
+#define TYPE_OBJECT             0x0
+#define TYPE_INTERFACE          0x1
+#define TYPE_PRIMITIVE          0x2
+#define TYPE_ENUM               0x3
+#define TYPE_STRING             0x4
+#define TYPE_WSTRING            0x5
+#define TYPE_STRUCTURE          0x6
+#define TYPE_UNION              0x7
+#define TYPE_ARRAY              0x8
+#define TYPE_SEQUENCE           0x9
+
+//these require the pack/unpack to recurse
+//so it's a hint to those languages that can optimize in cases where
+//recursion isn't necessary.
+#define TYPE_COMPLEX_STRUCTURE  (0x10 | TYPE_STRUCTURE)
+#define TYPE_COMPLEX_UNION      (0x10 | TYPE_UNION)
+#define TYPE_COMPLEX_ARRAY      (0x10 | TYPE_ARRAY)
+#define TYPE_COMPLEX_SEQUENCE   (0x10 | TYPE_SEQUENCE)
+
+
+typedef struct Type Type;
+
+#define INHERIT_TYPE\
+   int32_t nativeSize;                /*in the simple case its the same as wire size and alignment*/\
+   union {\
+      struct {\
+         const uintptr_t         p1;\
+         const uintptr_t         p2;\
+      } _cast;\
+      struct {\
+         uint32_t  iid;\
+         uint32_t  bNotNil;\
+      } object;\
+      struct {\
+         const Type  *arrayType;\
+         int32_t      nItems;\
+      } array;\
+      struct {\
+         const Type *seqType;\
+         int32_t      nMaxLen;\
+      } seqSimple; \
+      struct {\
+         uint32_t bFloating;\
+         uint32_t bSigned;\
+      } prim; \
+      const SequenceType* seqComplex;\
+      const UnionType  *unionType;\
+      const StructType *structType;\
+      int32_t         stringMaxLen;\
+      uint8_t        bInterfaceNotNil;\
+   } param;\
+   uint8_t    type;\
+   uint8_t    nativeAlignment\
+
+typedef struct UnionType UnionType;
+typedef struct StructType StructType;
+typedef struct SequenceType SequenceType;
+struct Type {
+   INHERIT_TYPE;
+};
+
+struct SequenceType {
+   const Type *         seqType;
+   uint32_t               nMaxLen;
+   uint32_t               inSize;
+   uint32_t               routSizePrimIn;
+   uint32_t               routSizePrimROut;
+};
+
+//byte offset from the start of the case values for
+//this unions case value array.  it MUST be aligned
+//at the alignment requrements for the descriptor
+//
+//if negative it means that the unions cases are
+//simple enumerators, so the value read from the descriptor
+//can be used directly to find the correct case
+typedef union CaseValuePtr CaseValuePtr;
+union CaseValuePtr {
+   const uint8_t*   value8s;
+   const uint16_t*  value16s;
+   const uint32_t*  value32s;
+   const uint64_t*  value64s;
+};
+
+//these are only used in complex cases
+//so I pulled them out of the type definition as references to make
+//the type smaller
+struct UnionType {
+   const Type           *descriptor;
+   uint32_t               nCases;
+   const CaseValuePtr   caseValues;
+   const Type * const   *cases;
+   int32_t               inSize;
+   int32_t               routSizePrimIn;
+   int32_t               routSizePrimROut;
+   uint8_t                inAlignment;
+   uint8_t                routAlignmentPrimIn;
+   uint8_t                routAlignmentPrimROut;
+   uint8_t                inCaseAlignment;
+   uint8_t                routCaseAlignmentPrimIn;
+   uint8_t                routCaseAlignmentPrimROut;
+   uint8_t                nativeCaseAlignment;
+   uint8_t              bDefaultCase;
+};
+
+struct StructType {
+   uint32_t               nMembers;
+   const Type * const   *members;
+   int32_t               inSize;
+   int32_t               routSizePrimIn;
+   int32_t               routSizePrimROut;
+   uint8_t                inAlignment;
+   uint8_t                routAlignmentPrimIn;
+   uint8_t                routAlignmentPrimROut;
+};
+
+typedef struct Parameter Parameter;
+struct Parameter {
+   INHERIT_TYPE;
+   uint8_t    mode;
+   uint8_t  bNotNil;
+};
+
+#define SLIM_IFPTR32(is32,is64) (sizeof(uintptr_t) == 4 ? (is32) : (is64))
+#define SLIM_SCALARS_IS_DYNAMIC(u) (((u) & 0x00ffffff) == 0x00ffffff)
+
+typedef struct Method Method;
+struct Method {
+   uint32_t                    uScalars;            //no method index
+   int32_t                     primInSize;
+   int32_t                     primROutSize;
+   int                         maxArgs;
+   int                         numParams;
+   const Parameter * const     *params;
+   uint8_t                       primInAlignment;
+   uint8_t                       primROutAlignment;
+};
+
+typedef struct Interface Interface;
+
+struct Interface {
+   int                            nMethods;
+   const Method  * const          *methodArray;
+   int                            nIIds;
+   const uint32_t                   *iids;
+   const uint16_t*                  methodStringArray;
+   const uint16_t*                  methodStrings;
+   const char*                    strings;
+};
+
+
+#endif //SLIM_H
+
 
 #ifndef _CALCULATOR_SLIM_H
 #define _CALCULATOR_SLIM_H
@@ -424,22 +424,31 @@ static const Type types[1];
 static const Type types[1] = {{0x4,{{(const uintptr_t)0,(const uintptr_t)1}}, 2,0x4}};
 static const Parameter parameters[2] = {{SLIM_IFPTR32(0x8,0x10),{{(const uintptr_t)&(types[0]),(const uintptr_t)0x0}}, 9,SLIM_IFPTR32(0x4,0x8),0,0},{0x8,{{(const uintptr_t)0,(const uintptr_t)1}}, 2,0x8,3,0}};
 static const Parameter* const parameterArrays[2] = {(&(parameters[0])),(&(parameters[1]))};
-static const Method methods[1] = {{REMOTE_SCALARS_MAKEX(0,0,0x2,0x1,0x0,0x0),0x4,0x8,3,2,(&(parameterArrays[0])),0x4,0x8}};
-static const Method* const methodArrays[1] = {&(methods[0])};
-static const char strings[13] = "res\0vec\0sum\0";
-static const uint16_t methodStrings[3] = {8,4,0};
-static const uint16_t methodStringsArrays[1] = {0};
-__QAIC_SLIM_EXPORT const Interface __QAIC_SLIM(calculator_slim) = {1,&(methodArrays[0]),0,0,&(methodStringsArrays [0]),methodStrings,strings};
+static const Method methods[2] = {{REMOTE_SCALARS_MAKEX(0,0,0x2,0x1,0x0,0x0),0x4,0x8,3,2,(&(parameterArrays[0])),0x4,0x8},{REMOTE_SCALARS_MAKEX(0,0,0x0,0x0,0x0,0x0),0x0,0x0,0,0,0,0x0,0x0}};
+static const Method* const methodArrays[2] = {&(methods[0]),&(methods[1])};
+static const char strings[18] = "sum2\0res\0vec\0sum\0";
+static const uint16_t methodStrings[4] = {13,9,5,0};
+static const uint16_t methodStringsArrays[2] = {0,3};
+__QAIC_SLIM_EXPORT const Interface __QAIC_SLIM(calculator_slim) = {2,&(methodArrays[0]),0,0,&(methodStringsArrays [0]),methodStrings,strings};
 #endif //_CALCULATOR_SLIM_H
 extern int adsp_mmap_fd_getinfo(int, uint32_t *);
 #ifdef __cplusplus
 extern "C" {
 #endif
-static __inline int _skel_method(int (*_pfn)(const int*, int, int64*), uint32_t _sc, remote_arg* _pra) {
+static __inline int _skel_method(int (*_pfn)(void), uint32_t _sc, remote_arg* _pra) {
+   remote_arg* _praEnd;
+   int _nErr = 0;
+   _praEnd = ((_pra + REMOTE_SCALARS_INBUFS(_sc)) + REMOTE_SCALARS_OUTBUFS(_sc) + REMOTE_SCALARS_INHANDLES(_sc) + REMOTE_SCALARS_OUTHANDLES(_sc));
+   _ASSERT(_nErr, (_pra + ((0 + 0) + (((0 + 0) + 0) + 0))) <= _praEnd);
+   _TRY(_nErr, _pfn());
+   _CATCH(_nErr) {}
+   return _nErr;
+}
+static __inline int _skel_method_1(int (*_pfn)(const int*, int, int64*), uint32_t _sc, remote_arg* _pra) {
    remote_arg* _praEnd;
-   const int* _in0[1];
-   int _in0Len[1];
-   int64 _rout1[1];
+   char* _in0[1];
+   uint32_t _in0Len[1];
+   uint64_t _rout1[1];
    uint32_t* _primIn;
    int _numIn[1];
    uint64_t* _primROut;
@@ -454,9 +463,9 @@ static __inline int _skel_method(int (*_pfn)(const int*, int, int64*), uint32_t
    _primROut = _pra[(_numIn[0] + 1)].buf.pv;
    _COPY(_in0Len, 0, _primIn, 0, 4);
    _praIn = (_pra + 1);
-   _ASSERT(_nErr, (int)((_praIn[0].buf.nLen / 4)) >= (int)(_in0Len[0]));
+   _ASSERT(_nErr, ((_praIn[0].buf.nLen / 4)) >= (size_t)(_in0Len[0]));
    _in0[0] = _praIn[0].buf.pv;
-   _TRY(_nErr, _pfn(*_in0, *_in0Len, _rout1));
+   _TRY(_nErr, _pfn((const int*)*_in0, (int)*_in0Len, (int64*)_rout1));
    _COPY(_primROut, 0, _rout1, 0, 8);
    _CATCH(_nErr) {}
    return _nErr;
@@ -465,7 +474,9 @@ __QAIC_SKEL_EXPORT int __QAIC_SKEL(calculator_skel_invoke)(uint32_t _sc, remote_
    switch(REMOTE_SCALARS_METHOD(_sc))
    {
       case 0:
-      return _skel_method((void*)__QAIC_IMPL(calculator_sum), _sc, _pra);
+      return _skel_method_1(__QAIC_IMPL(calculator_sum), _sc, _pra);
+      case 1:
+      return _skel_method(__QAIC_IMPL(calculator_sum2), _sc, _pra);
    }
    return AEE_EUNSUPPORTED;
 }
diff --git a/demo/out/calculator_stub.c b/demo/out/calculator_stub.c
index d8b1cbc..f41f95e 100644
--- a/demo/out/calculator_stub.c
+++ b/demo/out/calculator_stub.c
@@ -1,412 +1,412 @@
 #ifndef _CALCULATOR_STUB_H
 #define _CALCULATOR_STUB_H
 #include "calculator.h"
-#ifndef _QAIC_ENV_H
-#define _QAIC_ENV_H
-
-#ifdef __GNUC__
-#ifdef __clang__
-#pragma GCC diagnostic ignored "-Wunknown-pragmas"
-#else
-#pragma GCC diagnostic ignored "-Wpragmas"
-#endif
-#pragma GCC diagnostic ignored "-Wuninitialized"
-#pragma GCC diagnostic ignored "-Wunused-parameter"
-#pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-#ifndef _ATTRIBUTE_UNUSED
-
-#ifdef _WIN32
-#define _ATTRIBUTE_UNUSED
-#else
-#define _ATTRIBUTE_UNUSED __attribute__ ((unused))
-#endif
-
-#endif // _ATTRIBUTE_UNUSED
-
-#ifndef __QAIC_REMOTE
-#define __QAIC_REMOTE(ff) ff
-#endif //__QAIC_REMOTE
-
-#ifndef __QAIC_HEADER
-#define __QAIC_HEADER(ff) ff
-#endif //__QAIC_HEADER
-
-#ifndef __QAIC_HEADER_EXPORT
-#define __QAIC_HEADER_EXPORT
-#endif // __QAIC_HEADER_EXPORT
-
-#ifndef __QAIC_HEADER_ATTRIBUTE
-#define __QAIC_HEADER_ATTRIBUTE
-#endif // __QAIC_HEADER_ATTRIBUTE
-
-#ifndef __QAIC_IMPL
-#define __QAIC_IMPL(ff) ff
-#endif //__QAIC_IMPL
-
-#ifndef __QAIC_IMPL_EXPORT
-#define __QAIC_IMPL_EXPORT
-#endif // __QAIC_IMPL_EXPORT
-
-#ifndef __QAIC_IMPL_ATTRIBUTE
-#define __QAIC_IMPL_ATTRIBUTE
-#endif // __QAIC_IMPL_ATTRIBUTE
-
-#ifndef __QAIC_STUB
-#define __QAIC_STUB(ff) ff
-#endif //__QAIC_STUB
-
-#ifndef __QAIC_STUB_EXPORT
-#define __QAIC_STUB_EXPORT
-#endif // __QAIC_STUB_EXPORT
-
-#ifndef __QAIC_STUB_ATTRIBUTE
-#define __QAIC_STUB_ATTRIBUTE
-#endif // __QAIC_STUB_ATTRIBUTE
-
-#ifndef __QAIC_SKEL
-#define __QAIC_SKEL(ff) ff
-#endif //__QAIC_SKEL__
-
-#ifndef __QAIC_SKEL_EXPORT
-#define __QAIC_SKEL_EXPORT
-#endif // __QAIC_SKEL_EXPORT
-
-#ifndef __QAIC_SKEL_ATTRIBUTE
-#define __QAIC_SKEL_ATTRIBUTE
-#endif // __QAIC_SKEL_ATTRIBUTE
-
-#ifdef __QAIC_DEBUG__
-   #ifndef __QAIC_DBG_PRINTF__
-   #include <stdio.h>
-   #define __QAIC_DBG_PRINTF__( ee ) do { printf ee ; } while(0)
-   #endif
-#else
-   #define __QAIC_DBG_PRINTF__( ee ) (void)0
-#endif
-
-
-#define _OFFSET(src, sof)  ((void*)(((char*)(src)) + (sof)))
-
-#define _COPY(dst, dof, src, sof, sz)  \
-   do {\
-         struct __copy { \
-            char ar[sz]; \
-         };\
-         *(struct __copy*)_OFFSET(dst, dof) = *(struct __copy*)_OFFSET(src, sof);\
-   } while (0)
-
-#define _COPYIF(dst, dof, src, sof, sz)  \
-   do {\
-      if(_OFFSET(dst, dof) != _OFFSET(src, sof)) {\
-         _COPY(dst, dof, src, sof, sz); \
-      } \
-   } while (0)
-
-_ATTRIBUTE_UNUSED
-static __inline void _qaic_memmove(void* dst, void* src, int size) {
-   int i;
-   for(i = 0; i < size; ++i) {
-      ((char*)dst)[i] = ((char*)src)[i];
-   }
-}
-
-#define _MEMMOVEIF(dst, src, sz)  \
-   do {\
-      if(dst != src) {\
-         _qaic_memmove(dst, src, sz);\
-      } \
-   } while (0)
-
-
-#define _ASSIGN(dst, src, sof)  \
-   do {\
-      dst = OFFSET(src, sof); \
-   } while (0)
-
-#define _STD_STRLEN_IF(str) (str == 0 ? 0 : strlen(str))
-
-#include "AEEStdErr.h"
-
-#define _TRY(ee, func) \
-   do { \
-      if (AEE_SUCCESS != ((ee) = func)) {\
-         __QAIC_DBG_PRINTF__((__FILE__ ":%d:error:%d:%s\n", __LINE__, (int)(ee),#func));\
-         goto ee##bail;\
-      } \
-   } while (0)
-
-#define _CATCH(exception) exception##bail: if (exception != AEE_SUCCESS)
-
-#define _ASSERT(nErr, ff) _TRY(nErr, 0 == (ff) ? AEE_EBADPARM : AEE_SUCCESS)
-
-#ifdef __QAIC_DEBUG__
-#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, __FILE_LINE__, size, alignment, (void**)&pv));\
-                                                  _ASSERT(nErr,pv || !(size))   
-#else
-#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, 0, size, alignment, (void**)&pv));\
-                                                  _ASSERT(nErr,pv || !(size))
-#endif
-
-
-#endif // _QAIC_ENV_H
+#ifndef _QAIC_ENV_H
+#define _QAIC_ENV_H
+
+#ifdef __GNUC__
+#ifdef __clang__
+#pragma GCC diagnostic ignored "-Wunknown-pragmas"
+#else
+#pragma GCC diagnostic ignored "-Wpragmas"
+#endif
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#pragma GCC diagnostic ignored "-Wunused-parameter"
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
+#ifndef _ATTRIBUTE_UNUSED
+
+#ifdef _WIN32
+#define _ATTRIBUTE_UNUSED
+#else
+#define _ATTRIBUTE_UNUSED __attribute__ ((unused))
+#endif
+
+#endif // _ATTRIBUTE_UNUSED
+
+#ifndef __QAIC_REMOTE
+#define __QAIC_REMOTE(ff) ff
+#endif //__QAIC_REMOTE
+
+#ifndef __QAIC_HEADER
+#define __QAIC_HEADER(ff) ff
+#endif //__QAIC_HEADER
+
+#ifndef __QAIC_HEADER_EXPORT
+#define __QAIC_HEADER_EXPORT
+#endif // __QAIC_HEADER_EXPORT
+
+#ifndef __QAIC_HEADER_ATTRIBUTE
+#define __QAIC_HEADER_ATTRIBUTE
+#endif // __QAIC_HEADER_ATTRIBUTE
+
+#ifndef __QAIC_IMPL
+#define __QAIC_IMPL(ff) ff
+#endif //__QAIC_IMPL
+
+#ifndef __QAIC_IMPL_EXPORT
+#define __QAIC_IMPL_EXPORT
+#endif // __QAIC_IMPL_EXPORT
+
+#ifndef __QAIC_IMPL_ATTRIBUTE
+#define __QAIC_IMPL_ATTRIBUTE
+#endif // __QAIC_IMPL_ATTRIBUTE
+
+#ifndef __QAIC_STUB
+#define __QAIC_STUB(ff) ff
+#endif //__QAIC_STUB
+
+#ifndef __QAIC_STUB_EXPORT
+#define __QAIC_STUB_EXPORT
+#endif // __QAIC_STUB_EXPORT
+
+#ifndef __QAIC_STUB_ATTRIBUTE
+#define __QAIC_STUB_ATTRIBUTE
+#endif // __QAIC_STUB_ATTRIBUTE
+
+#ifndef __QAIC_SKEL
+#define __QAIC_SKEL(ff) ff
+#endif //__QAIC_SKEL__
+
+#ifndef __QAIC_SKEL_EXPORT
+#define __QAIC_SKEL_EXPORT
+#endif // __QAIC_SKEL_EXPORT
+
+#ifndef __QAIC_SKEL_ATTRIBUTE
+#define __QAIC_SKEL_ATTRIBUTE
+#endif // __QAIC_SKEL_ATTRIBUTE
+
+#ifdef __QAIC_DEBUG__
+   #ifndef __QAIC_DBG_PRINTF__
+   #include <stdio.h>
+   #define __QAIC_DBG_PRINTF__( ee ) do { printf ee ; } while(0)
+   #endif
+#else
+   #define __QAIC_DBG_PRINTF__( ee ) (void)0
+#endif
+
+
+#define _OFFSET(src, sof)  ((void*)(((char*)(src)) + (sof)))
+
+#define _COPY(dst, dof, src, sof, sz)  \
+   do {\
+         struct __copy { \
+            char ar[sz]; \
+         };\
+         *(struct __copy*)_OFFSET(dst, dof) = *(struct __copy*)_OFFSET(src, sof);\
+   } while (0)
+
+#define _COPYIF(dst, dof, src, sof, sz)  \
+   do {\
+      if(_OFFSET(dst, dof) != _OFFSET(src, sof)) {\
+         _COPY(dst, dof, src, sof, sz); \
+      } \
+   } while (0)
+
+_ATTRIBUTE_UNUSED
+static __inline void _qaic_memmove(void* dst, void* src, int size) {
+   int i;
+   for(i = 0; i < size; ++i) {
+      ((char*)dst)[i] = ((char*)src)[i];
+   }
+}
+
+#define _MEMMOVEIF(dst, src, sz)  \
+   do {\
+      if(dst != src) {\
+         _qaic_memmove(dst, src, sz);\
+      } \
+   } while (0)
+
+
+#define _ASSIGN(dst, src, sof)  \
+   do {\
+      dst = OFFSET(src, sof); \
+   } while (0)
+
+#define _STD_STRLEN_IF(str) (str == 0 ? 0 : strlen(str))
+
+#include "AEEStdErr.h"
+
+#define _TRY(ee, func) \
+   do { \
+      if (AEE_SUCCESS != ((ee) = func)) {\
+         __QAIC_DBG_PRINTF__((__FILE__ ":%d:error:%d:%s\n", __LINE__, (int)(ee),#func));\
+         goto ee##bail;\
+      } \
+   } while (0)
+
+#define _CATCH(exception) exception##bail: if (exception != AEE_SUCCESS)
+
+#define _ASSERT(nErr, ff) _TRY(nErr, 0 == (ff) ? AEE_EBADPARM : AEE_SUCCESS)
+
+#ifdef __QAIC_DEBUG__
+#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, __FILE_LINE__, size, alignment, (void**)&pv));\
+                                                  _ASSERT(nErr,pv || !(size))
+#else
+#define _ALLOCATE(nErr, pal, size, alignment, pv) _TRY(nErr, _allocator_alloc(pal, 0, size, alignment, (void**)&pv));\
+                                                  _ASSERT(nErr,pv || !(size))
+#endif
+
+
+#endif // _QAIC_ENV_H
 
 #include "remote.h"
-#ifndef _ALLOCATOR_H
-#define _ALLOCATOR_H
-
-#include <stdlib.h>
-#include <stdint.h>
-
-typedef struct _heap _heap;
-struct _heap {
-   _heap* pPrev;
-   const char* loc;
-   uint64_t buf;
-};
-
-typedef struct _allocator {
-   _heap* pheap;
-   uint8_t* stack;
-   uint8_t* stackEnd;
-   int nSize;
-} _allocator;
-
-_ATTRIBUTE_UNUSED
-static __inline int _heap_alloc(_heap** ppa, const char* loc, int size, void** ppbuf) {
-   _heap* pn = 0;
-   pn = malloc(size + sizeof(_heap) - sizeof(uint64_t));
-   if(pn != 0) {
-      pn->pPrev = *ppa;
-      pn->loc = loc;
-      *ppa = pn;
-      *ppbuf = (void*)&(pn->buf);
-      return 0;
-   } else {
-      return -1;
-   }
-}
-#define _ALIGN_SIZE(x, y) (((x) + (y-1)) & ~(y-1))
-
-_ATTRIBUTE_UNUSED
-static __inline int _allocator_alloc(_allocator* me,
-                                    const char* loc,
-                                    int size,
-                                    unsigned int al,
-                                    void** ppbuf) {
-   if(size < 0) {
-      return -1;
-   } else if (size == 0) {
-      *ppbuf = 0;
-      return 0;
-   }
-   if((_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size) < (uintptr_t)me->stack + me->nSize) {
-      *ppbuf = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al);
-      me->stackEnd = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size;
-      return 0;
-   } else {
-      return _heap_alloc(&me->pheap, loc, size, ppbuf);
-   }
-}
-
-_ATTRIBUTE_UNUSED
-static __inline void _allocator_deinit(_allocator* me) {
-   _heap* pa = me->pheap;
-   while(pa != 0) {
-      _heap* pn = pa;
-      const char* loc = pn->loc;
-      (void)loc;
-      pa = pn->pPrev;
-      free(pn);
-   }
-}
-
-_ATTRIBUTE_UNUSED
-static __inline void _allocator_init(_allocator* me, uint8_t* stack, int stackSize) {
-   me->stack =  stack;
-   me->stackEnd =  stack + stackSize;
-   me->nSize = stackSize;
-   me->pheap = 0;
-}
-
-
-#endif // _ALLOCATOR_H
-
-#ifndef SLIM_H
-#define SLIM_H
-
-#include <stdint.h>
-
-//a C data structure for the idl types that can be used to implement
-//static and dynamic language bindings fairly efficiently.
-//
-//the goal is to have a minimal ROM and RAM footprint and without
-//doing too many allocations.  A good way to package these things seemed
-//like the module boundary, so all the idls within  one module can share
-//all the type references.
-
-
-#define PARAMETER_IN       0x0
-#define PARAMETER_OUT      0x1
-#define PARAMETER_INOUT    0x2
-#define PARAMETER_ROUT     0x3
-#define PARAMETER_INROUT   0x4
-
-//the types that we get from idl
-#define TYPE_OBJECT             0x0
-#define TYPE_INTERFACE          0x1
-#define TYPE_PRIMITIVE          0x2
-#define TYPE_ENUM               0x3
-#define TYPE_STRING             0x4
-#define TYPE_WSTRING            0x5
-#define TYPE_STRUCTURE          0x6
-#define TYPE_UNION              0x7
-#define TYPE_ARRAY              0x8
-#define TYPE_SEQUENCE           0x9
-
-//these require the pack/unpack to recurse
-//so it's a hint to those languages that can optimize in cases where
-//recursion isn't necessary.
-#define TYPE_COMPLEX_STRUCTURE  (0x10 | TYPE_STRUCTURE)
-#define TYPE_COMPLEX_UNION      (0x10 | TYPE_UNION)
-#define TYPE_COMPLEX_ARRAY      (0x10 | TYPE_ARRAY)
-#define TYPE_COMPLEX_SEQUENCE   (0x10 | TYPE_SEQUENCE)
-
-
-typedef struct Type Type;
-
-#define INHERIT_TYPE\
-   int32_t nativeSize;                /*in the simple case its the same as wire size and alignment*/\
-   union {\
-      struct {\
-         const uintptr_t         p1;\
-         const uintptr_t         p2;\
-      } _cast;\
-      struct {\
-         uint32_t  iid;\
-         uint32_t  bNotNil;\
-      } object;\
-      struct {\
-         const Type  *arrayType;\
-         int32_t      nItems;\
-      } array;\
-      struct {\
-         const Type *seqType;\
-         int32_t      nMaxLen;\
-      } seqSimple; \
-      struct {\
-         uint32_t bFloating;\
-         uint32_t bSigned;\
-      } prim; \
-      const SequenceType* seqComplex;\
-      const UnionType  *unionType;\
-      const StructType *structType;\
-      int32_t         stringMaxLen;\
-      uint8_t        bInterfaceNotNil;\
-   } param;\
-   uint8_t    type;\
-   uint8_t    nativeAlignment\
-
-typedef struct UnionType UnionType;
-typedef struct StructType StructType;
-typedef struct SequenceType SequenceType;
-struct Type {
-   INHERIT_TYPE;
-};
-
-struct SequenceType {
-   const Type *         seqType;
-   uint32_t               nMaxLen;
-   uint32_t               inSize;
-   uint32_t               routSizePrimIn;
-   uint32_t               routSizePrimROut;
-};
-
-//byte offset from the start of the case values for
-//this unions case value array.  it MUST be aligned
-//at the alignment requrements for the descriptor
-//
-//if negative it means that the unions cases are
-//simple enumerators, so the value read from the descriptor
-//can be used directly to find the correct case
-typedef union CaseValuePtr CaseValuePtr;
-union CaseValuePtr {
-   const uint8_t*   value8s;
-   const uint16_t*  value16s;
-   const uint32_t*  value32s;
-   const uint64_t*  value64s;
-};
-
-//these are only used in complex cases
-//so I pulled them out of the type definition as references to make
-//the type smaller
-struct UnionType {
-   const Type           *descriptor;
-   uint32_t               nCases;
-   const CaseValuePtr   caseValues;
-   const Type * const   *cases;
-   int32_t               inSize;
-   int32_t               routSizePrimIn;
-   int32_t               routSizePrimROut;
-   uint8_t                inAlignment;
-   uint8_t                routAlignmentPrimIn;
-   uint8_t                routAlignmentPrimROut;
-   uint8_t                inCaseAlignment;
-   uint8_t                routCaseAlignmentPrimIn;
-   uint8_t                routCaseAlignmentPrimROut;
-   uint8_t                nativeCaseAlignment;
-   uint8_t              bDefaultCase;
-};
-
-struct StructType {
-   uint32_t               nMembers;
-   const Type * const   *members;
-   int32_t               inSize;
-   int32_t               routSizePrimIn;
-   int32_t               routSizePrimROut;
-   uint8_t                inAlignment;
-   uint8_t                routAlignmentPrimIn;
-   uint8_t                routAlignmentPrimROut;
-};
-
-typedef struct Parameter Parameter;
-struct Parameter {
-   INHERIT_TYPE;
-   uint8_t    mode;
-   uint8_t  bNotNil;
-};
-
-#define SLIM_IFPTR32(is32,is64) (sizeof(uintptr_t) == 4 ? (is32) : (is64))
-#define SLIM_SCALARS_IS_DYNAMIC(u) (((u) & 0x00ffffff) == 0x00ffffff)
-
-typedef struct Method Method;
-struct Method {
-   uint32_t                    uScalars;            //no method index
-   int32_t                     primInSize;
-   int32_t                     primROutSize;
-   int                         maxArgs;
-   int                         numParams;
-   const Parameter * const     *params;
-   uint8_t                       primInAlignment;
-   uint8_t                       primROutAlignment;
-};
-
-typedef struct Interface Interface;
-
-struct Interface {
-   int                            nMethods;
-   const Method  * const          *methodArray;
-   int                            nIIds;
-   const uint32_t                   *iids;
-   const uint16_t*                  methodStringArray;
-   const uint16_t*                  methodStrings;
-   const char*                    strings;
-};
-
-
-#endif //SLIM_H
-
+#ifndef _ALLOCATOR_H
+#define _ALLOCATOR_H
+
+#include <stdlib.h>
+#include <stdint.h>
+
+typedef struct _heap _heap;
+struct _heap {
+   _heap* pPrev;
+   const char* loc;
+   uint64_t buf;
+};
+
+typedef struct _allocator {
+   _heap* pheap;
+   uint8_t* stack;
+   uint8_t* stackEnd;
+   int nSize;
+} _allocator;
+
+_ATTRIBUTE_UNUSED
+static __inline int _heap_alloc(_heap** ppa, const char* loc, int size, void** ppbuf) {
+   _heap* pn = 0;
+   pn = malloc(size + sizeof(_heap) - sizeof(uint64_t));
+   if(pn != 0) {
+      pn->pPrev = *ppa;
+      pn->loc = loc;
+      *ppa = pn;
+      *ppbuf = (void*)&(pn->buf);
+      return 0;
+   } else {
+      return -1;
+   }
+}
+#define _ALIGN_SIZE(x, y) (((x) + (y-1)) & ~(y-1))
+
+_ATTRIBUTE_UNUSED
+static __inline int _allocator_alloc(_allocator* me,
+                                    const char* loc,
+                                    int size,
+                                    unsigned int al,
+                                    void** ppbuf) {
+   if(size < 0) {
+      return -1;
+   } else if (size == 0) {
+      *ppbuf = 0;
+      return 0;
+   }
+   if((_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size) < (uintptr_t)me->stack + me->nSize) {
+      *ppbuf = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al);
+      me->stackEnd = (uint8_t*)_ALIGN_SIZE((uintptr_t)me->stackEnd, al) + size;
+      return 0;
+   } else {
+      return _heap_alloc(&me->pheap, loc, size, ppbuf);
+   }
+}
+
+_ATTRIBUTE_UNUSED
+static __inline void _allocator_deinit(_allocator* me) {
+   _heap* pa = me->pheap;
+   while(pa != 0) {
+      _heap* pn = pa;
+      const char* loc = pn->loc;
+      (void)loc;
+      pa = pn->pPrev;
+      free(pn);
+   }
+}
+
+_ATTRIBUTE_UNUSED
+static __inline void _allocator_init(_allocator* me, uint8_t* stack, int stackSize) {
+   me->stack =  stack;
+   me->stackEnd =  stack + stackSize;
+   me->nSize = stackSize;
+   me->pheap = 0;
+}
+
+
+#endif // _ALLOCATOR_H
+
+#ifndef SLIM_H
+#define SLIM_H
+
+#include <stdint.h>
+
+//a C data structure for the idl types that can be used to implement
+//static and dynamic language bindings fairly efficiently.
+//
+//the goal is to have a minimal ROM and RAM footprint and without
+//doing too many allocations.  A good way to package these things seemed
+//like the module boundary, so all the idls within  one module can share
+//all the type references.
+
+
+#define PARAMETER_IN       0x0
+#define PARAMETER_OUT      0x1
+#define PARAMETER_INOUT    0x2
+#define PARAMETER_ROUT     0x3
+#define PARAMETER_INROUT   0x4
+
+//the types that we get from idl
+#define TYPE_OBJECT             0x0
+#define TYPE_INTERFACE          0x1
+#define TYPE_PRIMITIVE          0x2
+#define TYPE_ENUM               0x3
+#define TYPE_STRING             0x4
+#define TYPE_WSTRING            0x5
+#define TYPE_STRUCTURE          0x6
+#define TYPE_UNION              0x7
+#define TYPE_ARRAY              0x8
+#define TYPE_SEQUENCE           0x9
+
+//these require the pack/unpack to recurse
+//so it's a hint to those languages that can optimize in cases where
+//recursion isn't necessary.
+#define TYPE_COMPLEX_STRUCTURE  (0x10 | TYPE_STRUCTURE)
+#define TYPE_COMPLEX_UNION      (0x10 | TYPE_UNION)
+#define TYPE_COMPLEX_ARRAY      (0x10 | TYPE_ARRAY)
+#define TYPE_COMPLEX_SEQUENCE   (0x10 | TYPE_SEQUENCE)
+
+
+typedef struct Type Type;
+
+#define INHERIT_TYPE\
+   int32_t nativeSize;                /*in the simple case its the same as wire size and alignment*/\
+   union {\
+      struct {\
+         const uintptr_t         p1;\
+         const uintptr_t         p2;\
+      } _cast;\
+      struct {\
+         uint32_t  iid;\
+         uint32_t  bNotNil;\
+      } object;\
+      struct {\
+         const Type  *arrayType;\
+         int32_t      nItems;\
+      } array;\
+      struct {\
+         const Type *seqType;\
+         int32_t      nMaxLen;\
+      } seqSimple; \
+      struct {\
+         uint32_t bFloating;\
+         uint32_t bSigned;\
+      } prim; \
+      const SequenceType* seqComplex;\
+      const UnionType  *unionType;\
+      const StructType *structType;\
+      int32_t         stringMaxLen;\
+      uint8_t        bInterfaceNotNil;\
+   } param;\
+   uint8_t    type;\
+   uint8_t    nativeAlignment\
+
+typedef struct UnionType UnionType;
+typedef struct StructType StructType;
+typedef struct SequenceType SequenceType;
+struct Type {
+   INHERIT_TYPE;
+};
+
+struct SequenceType {
+   const Type *         seqType;
+   uint32_t               nMaxLen;
+   uint32_t               inSize;
+   uint32_t               routSizePrimIn;
+   uint32_t               routSizePrimROut;
+};
+
+//byte offset from the start of the case values for
+//this unions case value array.  it MUST be aligned
+//at the alignment requrements for the descriptor
+//
+//if negative it means that the unions cases are
+//simple enumerators, so the value read from the descriptor
+//can be used directly to find the correct case
+typedef union CaseValuePtr CaseValuePtr;
+union CaseValuePtr {
+   const uint8_t*   value8s;
+   const uint16_t*  value16s;
+   const uint32_t*  value32s;
+   const uint64_t*  value64s;
+};
+
+//these are only used in complex cases
+//so I pulled them out of the type definition as references to make
+//the type smaller
+struct UnionType {
+   const Type           *descriptor;
+   uint32_t               nCases;
+   const CaseValuePtr   caseValues;
+   const Type * const   *cases;
+   int32_t               inSize;
+   int32_t               routSizePrimIn;
+   int32_t               routSizePrimROut;
+   uint8_t                inAlignment;
+   uint8_t                routAlignmentPrimIn;
+   uint8_t                routAlignmentPrimROut;
+   uint8_t                inCaseAlignment;
+   uint8_t                routCaseAlignmentPrimIn;
+   uint8_t                routCaseAlignmentPrimROut;
+   uint8_t                nativeCaseAlignment;
+   uint8_t              bDefaultCase;
+};
+
+struct StructType {
+   uint32_t               nMembers;
+   const Type * const   *members;
+   int32_t               inSize;
+   int32_t               routSizePrimIn;
+   int32_t               routSizePrimROut;
+   uint8_t                inAlignment;
+   uint8_t                routAlignmentPrimIn;
+   uint8_t                routAlignmentPrimROut;
+};
+
+typedef struct Parameter Parameter;
+struct Parameter {
+   INHERIT_TYPE;
+   uint8_t    mode;
+   uint8_t  bNotNil;
+};
+
+#define SLIM_IFPTR32(is32,is64) (sizeof(uintptr_t) == 4 ? (is32) : (is64))
+#define SLIM_SCALARS_IS_DYNAMIC(u) (((u) & 0x00ffffff) == 0x00ffffff)
+
+typedef struct Method Method;
+struct Method {
+   uint32_t                    uScalars;            //no method index
+   int32_t                     primInSize;
+   int32_t                     primROutSize;
+   int                         maxArgs;
+   int                         numParams;
+   const Parameter * const     *params;
+   uint8_t                       primInAlignment;
+   uint8_t                       primROutAlignment;
+};
+
+typedef struct Interface Interface;
+
+struct Interface {
+   int                            nMethods;
+   const Method  * const          *methodArray;
+   int                            nIIds;
+   const uint32_t                   *iids;
+   const uint16_t*                  methodStringArray;
+   const uint16_t*                  methodStrings;
+   const char*                    strings;
+};
+
+
+#endif //SLIM_H
+
 
 #ifndef _CALCULATOR_SLIM_H
 #define _CALCULATOR_SLIM_H
@@ -424,109 +424,109 @@ static const Type types[1];
 static const Type types[1] = {{0x4,{{(const uintptr_t)0,(const uintptr_t)1}}, 2,0x4}};
 static const Parameter parameters[2] = {{SLIM_IFPTR32(0x8,0x10),{{(const uintptr_t)&(types[0]),(const uintptr_t)0x0}}, 9,SLIM_IFPTR32(0x4,0x8),0,0},{0x8,{{(const uintptr_t)0,(const uintptr_t)1}}, 2,0x8,3,0}};
 static const Parameter* const parameterArrays[2] = {(&(parameters[0])),(&(parameters[1]))};
-static const Method methods[1] = {{REMOTE_SCALARS_MAKEX(0,0,0x2,0x1,0x0,0x0),0x4,0x8,3,2,(&(parameterArrays[0])),0x4,0x8}};
-static const Method* const methodArrays[1] = {&(methods[0])};
-static const char strings[13] = "res\0vec\0sum\0";
-static const uint16_t methodStrings[3] = {8,4,0};
-static const uint16_t methodStringsArrays[1] = {0};
-__QAIC_SLIM_EXPORT const Interface __QAIC_SLIM(calculator_slim) = {1,&(methodArrays[0]),0,0,&(methodStringsArrays [0]),methodStrings,strings};
+static const Method methods[2] = {{REMOTE_SCALARS_MAKEX(0,0,0x2,0x1,0x0,0x0),0x4,0x8,3,2,(&(parameterArrays[0])),0x4,0x8},{REMOTE_SCALARS_MAKEX(0,0,0x0,0x0,0x0,0x0),0x0,0x0,0,0,0,0x0,0x0}};
+static const Method* const methodArrays[2] = {&(methods[0]),&(methods[1])};
+static const char strings[18] = "sum2\0res\0vec\0sum\0";
+static const uint16_t methodStrings[4] = {13,9,5,0};
+static const uint16_t methodStringsArrays[2] = {0,3};
+__QAIC_SLIM_EXPORT const Interface __QAIC_SLIM(calculator_slim) = {2,&(methodArrays[0]),0,0,&(methodStringsArrays [0]),methodStrings,strings};
 #endif //_CALCULATOR_SLIM_H
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _const_calculator_handle
-#define _const_calculator_handle ((remote_handle)-1)
-#endif //_const_calculator_handle
-
-static void _calculator_pls_dtor(void* data) {
-   remote_handle* ph = (remote_handle*)data;
-   if(_const_calculator_handle != *ph) {
-      (void)__QAIC_REMOTE(remote_handle_close)(*ph);
-      *ph = _const_calculator_handle;
-   }
-}
-
-static int _calculator_pls_ctor(void* ctx, void* data) {
-   remote_handle* ph = (remote_handle*)data;
-   *ph = _const_calculator_handle;
-   if(*ph == (remote_handle)-1) {
-      return __QAIC_REMOTE(remote_handle_open)((const char*)ctx, ph);
-   }
-   return 0;
-}
-
-#if (defined __qdsp6__) || (defined __hexagon__)
-#pragma weak  adsp_pls_add_lookup
-extern int adsp_pls_add_lookup(uint32_t type, uint32_t key, int size, int (*ctor)(void* ctx, void* data), void* ctx, void (*dtor)(void* ctx), void** ppo);
-#pragma weak  HAP_pls_add_lookup
-extern int HAP_pls_add_lookup(uint32_t type, uint32_t key, int size, int (*ctor)(void* ctx, void* data), void* ctx, void (*dtor)(void* ctx), void** ppo);
-
-__QAIC_STUB_EXPORT remote_handle _calculator_handle(void) {
-   remote_handle* ph;
-   if(adsp_pls_add_lookup) {
-      if(0 == adsp_pls_add_lookup((uint32_t)_calculator_handle, 0, sizeof(*ph),  _calculator_pls_ctor, "calculator",  _calculator_pls_dtor, (void**)&ph))  {
-         return *ph;
-      }
-      return (remote_handle)-1;
-   } else if(HAP_pls_add_lookup) {
-      if(0 == HAP_pls_add_lookup((uint32_t)_calculator_handle, 0, sizeof(*ph),  _calculator_pls_ctor, "calculator",  _calculator_pls_dtor, (void**)&ph))  {
-         return *ph;
-      }
-      return (remote_handle)-1;
-   }
-   return(remote_handle)-1;
-}
-
-#else //__qdsp6__ || __hexagon__
-
-uint32_t _calculator_atomic_CompareAndExchange(uint32_t * volatile puDest, uint32_t uExchange, uint32_t uCompare);
-
-#ifdef _WIN32
-#include "Windows.h"
-uint32_t _calculator_atomic_CompareAndExchange(uint32_t * volatile puDest, uint32_t uExchange, uint32_t uCompare) {
-   return (uint32_t)InterlockedCompareExchange((volatile LONG*)puDest, (LONG)uExchange, (LONG)uCompare);
-}
-#elif __GNUC__
-uint32_t _calculator_atomic_CompareAndExchange(uint32_t * volatile puDest, uint32_t uExchange, uint32_t uCompare) {
-   return __sync_val_compare_and_swap(puDest, uCompare, uExchange);
-}
-#endif //_WIN32
-
-
-__QAIC_STUB_EXPORT remote_handle _calculator_handle(void) {
-   static remote_handle handle = _const_calculator_handle;
-   if((remote_handle)-1 != handle) {
-      return handle;
-   } else {
-      remote_handle tmp;
-      int nErr = _calculator_pls_ctor("calculator", (void*)&tmp);
-      if(nErr) {
-         return (remote_handle)-1;
-      }
-      if(((remote_handle)-1 != handle) || ((remote_handle)-1 != (remote_handle)_calculator_atomic_CompareAndExchange((uint32_t*)&handle, (uint32_t)tmp, (uint32_t)-1))) {
-         _calculator_pls_dtor(&tmp);
-      }
-      return handle;
-   }
-}
-
-#endif //__qdsp6__
-
-__QAIC_STUB_EXPORT int __QAIC_STUB(calculator_skel_invoke)(uint32_t _sc, remote_arg* _pra) __QAIC_STUB_ATTRIBUTE {
-   return __QAIC_REMOTE(remote_handle_invoke)(_calculator_handle(), _sc, _pra);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _const_calculator_handle
+#define _const_calculator_handle ((remote_handle)-1)
+#endif //_const_calculator_handle
+
+static void _calculator_pls_dtor(void* data) {
+   remote_handle* ph = (remote_handle*)data;
+   if(_const_calculator_handle != *ph) {
+      (void)__QAIC_REMOTE(remote_handle_close)(*ph);
+      *ph = _const_calculator_handle;
+   }
+}
+
+static int _calculator_pls_ctor(void* ctx, void* data) {
+   remote_handle* ph = (remote_handle*)data;
+   *ph = _const_calculator_handle;
+   if(*ph == (remote_handle)-1) {
+      return __QAIC_REMOTE(remote_handle_open)((const char*)ctx, ph);
+   }
+   return 0;
+}
+
+#if (defined __qdsp6__) || (defined __hexagon__)
+#pragma weak  adsp_pls_add_lookup
+extern int adsp_pls_add_lookup(uint32_t type, uint32_t key, int size, int (*ctor)(void* ctx, void* data), void* ctx, void (*dtor)(void* ctx), void** ppo);
+#pragma weak  HAP_pls_add_lookup
+extern int HAP_pls_add_lookup(uint32_t type, uint32_t key, int size, int (*ctor)(void* ctx, void* data), void* ctx, void (*dtor)(void* ctx), void** ppo);
+
+__QAIC_STUB_EXPORT remote_handle _calculator_handle(void) {
+   remote_handle* ph;
+   if(adsp_pls_add_lookup) {
+      if(0 == adsp_pls_add_lookup((uint32_t)_calculator_handle, 0, sizeof(*ph),  _calculator_pls_ctor, "calculator",  _calculator_pls_dtor, (void**)&ph))  {
+         return *ph;
+      }
+      return (remote_handle)-1;
+   } else if(HAP_pls_add_lookup) {
+      if(0 == HAP_pls_add_lookup((uint32_t)_calculator_handle, 0, sizeof(*ph),  _calculator_pls_ctor, "calculator",  _calculator_pls_dtor, (void**)&ph))  {
+         return *ph;
+      }
+      return (remote_handle)-1;
+   }
+   return(remote_handle)-1;
+}
+
+#else //__qdsp6__ || __hexagon__
+
+uint32_t _calculator_atomic_CompareAndExchange(uint32_t * volatile puDest, uint32_t uExchange, uint32_t uCompare);
+
+#ifdef _WIN32
+#include "Windows.h"
+uint32_t _calculator_atomic_CompareAndExchange(uint32_t * volatile puDest, uint32_t uExchange, uint32_t uCompare) {
+   return (uint32_t)InterlockedCompareExchange((volatile LONG*)puDest, (LONG)uExchange, (LONG)uCompare);
+}
+#elif __GNUC__
+uint32_t _calculator_atomic_CompareAndExchange(uint32_t * volatile puDest, uint32_t uExchange, uint32_t uCompare) {
+   return __sync_val_compare_and_swap(puDest, uCompare, uExchange);
+}
+#endif //_WIN32
+
+
+__QAIC_STUB_EXPORT remote_handle _calculator_handle(void) {
+   static remote_handle handle = _const_calculator_handle;
+   if((remote_handle)-1 != handle) {
+      return handle;
+   } else {
+      remote_handle tmp;
+      int nErr = _calculator_pls_ctor("calculator", (void*)&tmp);
+      if(nErr) {
+         return (remote_handle)-1;
+      }
+      if(((remote_handle)-1 != handle) || ((remote_handle)-1 != (remote_handle)_calculator_atomic_CompareAndExchange((uint32_t*)&handle, (uint32_t)tmp, (uint32_t)-1))) {
+         _calculator_pls_dtor(&tmp);
+      }
+      return handle;
+   }
+}
+
+#endif //__qdsp6__
+
+__QAIC_STUB_EXPORT int __QAIC_STUB(calculator_skel_invoke)(uint32_t _sc, remote_arg* _pra) __QAIC_STUB_ATTRIBUTE {
+   return __QAIC_REMOTE(remote_handle_invoke)(_calculator_handle(), _sc, _pra);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 extern int remote_register_dma_handle(int, uint32_t);
-static __inline int _stub_method(remote_handle _handle, uint32_t _mid, const int* _in0[1], int _in0Len[1], int64 _rout1[1]) {
+static __inline int _stub_method(remote_handle _handle, uint32_t _mid, char* _in0[1], uint32_t _in0Len[1], uint64_t _rout1[1]) {
    int _numIn[1];
    remote_arg _pra[3];
    uint32_t _primIn[1];
@@ -549,7 +549,18 @@ static __inline int _stub_method(remote_handle _handle, uint32_t _mid, const int
 }
 __QAIC_STUB_EXPORT int __QAIC_STUB(calculator_sum)(const int* vec, int vecLen, int64* res) __QAIC_STUB_ATTRIBUTE {
    uint32_t _mid = 0;
-   return _stub_method(_calculator_handle(), _mid, (const int**)&vec, (int*)&vecLen, (int64*)res);
+   return _stub_method(_calculator_handle(), _mid, (char**)&vec, (uint32_t*)&vecLen, (uint64_t*)res);
+}
+static __inline int _stub_method_1(remote_handle _handle, uint32_t _mid) {
+   remote_arg* _pra = 0;
+   int _nErr = 0;
+   _TRY(_nErr, __QAIC_REMOTE(remote_handle_invoke)(_handle, REMOTE_SCALARS_MAKEX(0, _mid, 0, 0, 0, 0), _pra));
+   _CATCH(_nErr) {}
+   return _nErr;
+}
+__QAIC_STUB_EXPORT int __QAIC_STUB(calculator_sum2)(void) __QAIC_STUB_ATTRIBUTE {
+   uint32_t _mid = 1;
+   return _stub_method_1(_calculator_handle(), _mid);
 }
 #ifdef __cplusplus
 }
diff --git a/demo/out/libcalculator_skel.so b/demo/out/libcalculator_skel.so
index 3a451b5..df231a0 100755
Binary files a/demo/out/libcalculator_skel.so and b/demo/out/libcalculator_skel.so differ
diff --git a/demo/run.c b/demo/run.c
index c868ba4..72c7f4e 100644
--- a/demo/run.c
+++ b/demo/run.c
@@ -15,20 +15,26 @@ void fix_path() {
   my_path[len-strlen("test_dsp")] = '\0';
 
   char adsp_path[PATH_MAX+1];
-  snprintf(adsp_path, PATH_MAX, "ADSP_LIBRARY_PATH=%s/out", my_path);
+  snprintf(adsp_path, PATH_MAX, "ADSP_LIBRARY_PATH=%sout", my_path);
   assert(putenv(adsp_path) == 0);
 }
 
 int main(int argc, char *argv[]) {
+  printf("hello world\n");
   fix_path();
+  printf("ADSP_LIBRARY_PATH=%s\n", getenv("ADSP_LIBRARY_PATH"));
 
   int vec[0x100];
   for (int i = 0; i < 0x100; i++) vec[i] = 1;
   int64 res = 0;
-
+  // printf("hello world2\n");
+  // calculator_sum2();
+  printf("hello world3\n");
   int ret = calculator_sum(vec, 0x100, &res);
-  assert(ret == 0);
+  printf("hello world4\n");
+  printf("ret %d\n", ret);
+  //assert(ret == 0);
   printf("got 0x%llx\n", res);
-  assert(res == 0x100);
+  //assert(res == 0x100);
 }
 
diff --git a/freethedsp.c b/freethedsp.c
index 34bf7a6..52f431b 100644
--- a/freethedsp.c
+++ b/freethedsp.c
@@ -19,10 +19,11 @@
 // patch to return 0xFFFFFFFF from is_test_enabled instead of 0
 // your fastrpc_shell_0 may vary
 #define PATCH_ADDR 0x5200c
-#define PATCH_OLD "\x40\x3f\x20\x50"
-#define PATCH_NEW "\x40\x3f\x00\x5a"
-#define PATCH_LEN (sizeof(PATCH_OLD)-1)
-
+// #define PATCH_OLD "\x40\x3f\x20\x50"
+// #define PATCH_NEW "\x40\x3f\x00\x5a"
+#define PATCH_OLD 0x50203f40
+#define PATCH_NEW 0x5a003f40
+#define PATCH_LEN 0x4
 // under 100 lines of code begins now
 #include <stdio.h>
 #include <dlfcn.h>
@@ -82,42 +83,80 @@ int ioctl(int fd, unsigned long request, void *arg) {
     assert(handle != NULL);
     orig_ioctl = dlsym(handle, "ioctl");
   }
+  printf("fastrpc_init1:   request: 0x%x\tfd: 0x%x", request, fd);
+  printf("\tfd: 0x%x\n", fd);
+  printf("\tflags: 0x%x\n", ((struct fastrpc_ioctl_init *) arg)->flags);
+  printf("\tfile: 0x%lx\n", ((struct fastrpc_ioctl_init *) arg)->file);
+  printf("\tfilelen: %d\n", ((struct fastrpc_ioctl_init *) arg)->filelen);
+  printf("\tfilefd: 0x%x\n", ((struct fastrpc_ioctl_init *) arg)->filefd);
+  printf("\tmem: 0x%lx\n", ((struct fastrpc_ioctl_init *) arg)->mem);
+  printf("\tmem+PATCH_ADDR: 0x%lx\n", ((struct fastrpc_ioctl_init *) arg)->mem+PATCH_ADDR);
+  printf("\tvoid * mem+PATCH_ADDR: 0x%lx\n", (void *)(((struct fastrpc_ioctl_init *) arg)->mem+PATCH_ADDR));
+  printf("\tPATCH_OLD: 0x%lx\n", (void *)PATCH_OLD);
+  printf("\tmemlen: 0x%x\n", ((struct fastrpc_ioctl_init *) arg)->memlen);
+  printf("\tmemfd: 0x%x\n", ((struct fastrpc_ioctl_init *) arg)->memfd);
 
   int ret = orig_ioctl(fd, request, arg);
 
-  // carefully modify this one
-  if (request == FASTRPC_IOCTL_INIT) {
-    struct fastrpc_ioctl_init *init = (struct fastrpc_ioctl_init *)arg;
-
-    // confirm patch is correct and do the patch
-    assert(memcmp((void*)(init->mem+PATCH_ADDR), PATCH_OLD, 4) == 0);
-    memcpy((void*)(init->mem+PATCH_ADDR), PATCH_NEW, 4);
-
-    // flush cache
-    int ionfd = open("/dev/ion", O_RDONLY);
-    assert(ionfd > 0);
-
-    struct ion_fd_data fd_data;
-    fd_data.fd = init->memfd;
-    int ret = ioctl(ionfd, ION_IOC_IMPORT, &fd_data);
-    assert(ret == 0);
-
-    struct ion_flush_data flush_data;
-    flush_data.handle  = fd_data.handle;
-    flush_data.vaddr   = (void*)init->mem;
-    flush_data.offset  = PATCH_ADDR;
-    flush_data.length  = PATCH_LEN;
-    ret = ioctl(ionfd, ION_IOC_CLEAN_INV_CACHES, &flush_data);
-    assert(ret == 0);
-
-    struct ion_handle_data handle_data;
-    handle_data.handle = fd_data.handle;
-    ret = ioctl(ionfd, ION_IOC_FREE, &handle_data);
-    assert(ret == 0);
-
-    // cleanup
-    close(ionfd);
-  }
+  struct fastrpc_ioctl_init *init = (struct fastrpc_ioctl_init *)arg;
+  printf("fastrpc_init2:\n");
+  printf("\tflags: 0x%x\n", init->flags);
+  printf("\tfile: 0x%lx\n", init->file);
+  printf("\tfilelen: %d\n", init->filelen);
+  printf("\tfilefd: 0x%x\n", init->filefd);
+  printf("\tmem: 0x%lx\n", init->mem);
+  printf("\tmem+PATCH_ADDR: 0x%lx\n", init->mem+PATCH_ADDR);
+  printf("\tvoid * mem+PATCH_ADDR: 0x%lx\n", (void *)(init->mem+PATCH_ADDR));
+  printf("\tPATCH_OLD: 0x%lx\n", (void *)PATCH_OLD);
+  printf("\tmemlen: 0x%x\n", init->memlen);
+  printf("\tmemfd: 0x%x\n", init->memfd);
+0xc0285206
+
+  // // carefully modify this one
+  // if (request == FASTRPC_IOCTL_INIT) {
+  //   struct fastrpc_ioctl_init *init = (struct fastrpc_ioctl_init *)arg;
+
+  //   printf("fastrpc_init2:\n");
+  //   printf("\tflags: 0x%x\n", init->flags);
+  //   printf("\tfile: 0x%lx\n", init->file);
+  //   printf("\tfilelen: %d\n", init->filelen);
+  //   printf("\tfilefd: 0x%x\n", init->filefd);
+  //   printf("\tmem: 0x%lx\n", init->mem);
+  //   printf("\tmem+PATCH_ADDR: 0x%lx\n", init->mem+PATCH_ADDR);
+  //   printf("\tvoid * mem+PATCH_ADDR: 0x%lx\n", (void *)(init->mem+PATCH_ADDR));
+  //   printf("\tPATCH_OLD: 0x%lx\n", (void *)PATCH_OLD);
+  //   printf("\tmemlen: 0x%x\n", init->memlen);
+  //   printf("\tmemfd: 0x%x\n", init->memfd);
+
+  //   // confirm patch is correct and do the patch
+  //   assert(memcmp((void*)(init->mem+PATCH_ADDR), (void *)PATCH_OLD, 4) == 0);
+  //   memcpy((void*)(init->mem+PATCH_ADDR), (void *)PATCH_NEW, 4);
+
+  //   // flush cache
+  //   int ionfd = open("/dev/ion", O_RDONLY);
+  //   assert(ionfd > 0);
+
+  //   struct ion_fd_data fd_data;
+  //   fd_data.fd = init->memfd;
+  //   int ret = ioctl(ionfd, ION_IOC_IMPORT, &fd_data);
+  //   assert(ret == 0);
+
+  //   struct ion_flush_data flush_data;
+  //   flush_data.handle  = fd_data.handle;
+  //   flush_data.vaddr   = (void*)init->mem;
+  //   flush_data.offset  = PATCH_ADDR;
+  //   flush_data.length  = PATCH_LEN;
+  //   ret = ioctl(ionfd, ION_IOC_CLEAN_INV_CACHES, &flush_data);
+  //   assert(ret == 0);
+
+  //   struct ion_handle_data handle_data;
+  //   handle_data.handle = fd_data.handle;
+  //   ret = ioctl(ionfd, ION_IOC_FREE, &handle_data);
+  //   assert(ret == 0);
+
+  //   // cleanup
+  //   close(ionfd);
+  // }
 
   return ret;
 }
